# 문제상황
개발 중 아래와 같은 요구사항이 들어왔다.

"1:N(N >=0)관계의 테이블 A와 B에 대하여, B가 하나라도 존재하는 모든 A의 데이터를 조회할 수 있게 해달라"

해당 조건을 만족하는 쿼리는 간단했다.

A와 B를 `INNER JOIN` 해주고, 1:N 관계에서 발생하는 A 데이터의 중복을 제거하기 위해 `DISTINCT`를 적용해주면 됐다.

이렇게 완성된 쿼리는 아래와 같았다.

```sql
SELECT DISTINCT a.id
FROM A a
INNER JOIN B b on a.id = b.a_id
WHERE ...;
```
하지만 `JOIN`을 사용하지 않고 위 쿼리와 동일한 결과를 가져올 수 있는 쿼리가 하나 더 있다.

바로 서브 쿼리를 사용하는 것이다.

`JOIN` 절을 이용해 B 테이블 데이터를 가져오는 쿼리를 별도 `SELECT` 쿼리 가져와, 결과값을 A 테이블의 `IN`절에 넣는 방식이다.

해당 쿼리는 아래와 같이 짜여질 수 있다.

```sql
SELECT a.id
FROM A a
WHERE a.id in (SELECT DISTINCT b.a_id FROM B b)
```
다만 일반적으로 서브쿼리는 안티패턴으로 취급받는기도 하고 성능 상 문제가 있을 수 있다는 얘기를 많이 들었어서(물론 5.6 버전부터 성능이 향상되었다곤 하다만), 최대한 `JOIN`으로 처리하고 하였다.

하지만 두 가지 방식에 대해 각각의 TPS를 확인한 결과 꽤 뚜렷한 차이가 있음을 확인할 수 있었다.